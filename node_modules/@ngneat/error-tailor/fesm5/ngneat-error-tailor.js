import { __decorate, __read, __assign, __param } from 'tslib';
import { ChangeDetectorRef, ElementRef, Component, ChangeDetectionStrategy, ViewContainerRef, Directive, InjectionToken, ComponentFactoryResolver, Inject, Optional, Self, Input, NgModule } from '@angular/core';
import { NgControl, ControlContainer } from '@angular/forms';
import { fromEvent, Subject, EMPTY, merge, NEVER } from 'rxjs';
import { tap, shareReplay, distinctUntilChanged, startWith, switchMap, mapTo, takeUntil } from 'rxjs/operators';
import { CommonModule } from '@angular/common';

var DefaultControlErrorComponent = /** @class */ (function () {
    function DefaultControlErrorComponent(cdr, host) {
        this.cdr = cdr;
        this.host = host;
        this.errorText = null;
        this.hideError = true;
    }
    DefaultControlErrorComponent.prototype.createTemplate = function (tpl, error, text) {
        this.errorTemplate = tpl;
        this.errorContext = { $implicit: error, text: text };
        this.cdr.markForCheck();
    };
    Object.defineProperty(DefaultControlErrorComponent.prototype, "customClass", {
        set: function (className) {
            this.host.nativeElement.classList.add(className);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultControlErrorComponent.prototype, "text", {
        set: function (value) {
            if (value !== this.errorText) {
                this.errorText = value;
                this.hideError = !value;
                this.cdr.markForCheck();
            }
        },
        enumerable: true,
        configurable: true
    });
    DefaultControlErrorComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    DefaultControlErrorComponent = __decorate([
        Component({
            selector: 'control-error',
            template: "\n    <label class=\"control-error\" [class.hide-control]=\"hideError\" *ngIf=\"!errorTemplate\">{{ errorText }}</label>\n    <ng-template *ngTemplateOutlet=\"errorTemplate; context: errorContext\"></ng-template>\n  ",
            changeDetection: ChangeDetectionStrategy.OnPush,
            styles: ["\n      .hide-control {\n        display: none !important;\n      }\n\n      :host {\n        display: block;\n      }\n    "]
        })
    ], DefaultControlErrorComponent);
    return DefaultControlErrorComponent;
}());

var ControlErrorAnchorDirective = /** @class */ (function () {
    function ControlErrorAnchorDirective(vcr) {
        this.vcr = vcr;
    }
    ControlErrorAnchorDirective.ctorParameters = function () { return [
        { type: ViewContainerRef }
    ]; };
    ControlErrorAnchorDirective = __decorate([
        Directive({
            selector: '[controlErrorAnchor]',
            exportAs: 'controlErrorAnchor'
        })
    ], ControlErrorAnchorDirective);
    return ControlErrorAnchorDirective;
}());

var FORM_ERRORS = new InjectionToken('FORM_ERRORS', {
    providedIn: 'root',
    factory: function () {
        return {};
    }
});
var ErrorTailorConfigProvider = new InjectionToken('ErrorTailorConfigProvider');

var FormActionDirective = /** @class */ (function () {
    function FormActionDirective(host) {
        var _this = this;
        this.host = host;
        this.submit$ = fromEvent(this.element, 'submit').pipe(tap(function () {
            if (_this.element.classList.contains('form-submitted') === false) {
                _this.element.classList.add('form-submitted');
            }
        }), shareReplay({ refCount: true, bufferSize: 1 }));
        this.reset$ = fromEvent(this.element, 'reset').pipe(tap(function () {
            _this.element.classList.remove('form-submitted');
        }), shareReplay({ refCount: true, bufferSize: 1 }));
    }
    Object.defineProperty(FormActionDirective.prototype, "element", {
        get: function () {
            return this.host.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    FormActionDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    FormActionDirective = __decorate([
        Directive({
            selector: 'form[errorTailor]'
        })
    ], FormActionDirective);
    return FormActionDirective;
}());

var ControlErrorsDirective = /** @class */ (function () {
    function ControlErrorsDirective(vcr, resolver, host, config, globalErrors, controlErrorAnchorParent, form, ngControl, controlContainer) {
        this.vcr = vcr;
        this.resolver = resolver;
        this.host = host;
        this.config = config;
        this.globalErrors = globalErrors;
        this.controlErrorAnchorParent = controlErrorAnchorParent;
        this.form = form;
        this.ngControl = ngControl;
        this.controlContainer = controlContainer;
        this.customErrors = {};
        this.controlErrorsOnAsync = true;
        this.controlErrorsOnBlur = true;
        this.destroy = new Subject();
        this.mergedConfig = {};
        this.submit$ = this.form ? this.form.submit$ : EMPTY;
        this.reset$ = this.form ? this.form.reset$ : EMPTY;
        this.mergedConfig = this.buildConfig();
    }
    ControlErrorsDirective.prototype.ngOnInit = function () {
        var _this = this;
        this.anchor = this.resolveAnchor();
        this.control = (this.controlContainer || this.ngControl).control;
        var hasAsyncValidator = !!this.control.asyncValidator;
        var isInput = this.mergedConfig.blurPredicate(this.host.nativeElement);
        var statusChanges$ = this.control.statusChanges.pipe(distinctUntilChanged());
        var valueChanges$ = this.control.valueChanges;
        var controlChanges$ = merge(statusChanges$, valueChanges$);
        var changesOnAsync$ = EMPTY;
        var changesOnBlur$ = EMPTY;
        if (this.controlErrorsOnAsync && hasAsyncValidator) {
            // hasAsyncThenUponStatusChange
            changesOnAsync$ = statusChanges$.pipe(startWith(true));
        }
        if (this.controlErrorsOnBlur && isInput) {
            var blur$ = fromEvent(this.host.nativeElement, 'focusout');
            // blurFirstThenUponChange
            changesOnBlur$ = blur$.pipe(switchMap(function () { return valueChanges$.pipe(startWith(true)); }));
        }
        var submit$ = merge(this.submit$.pipe(mapTo(true)), this.reset$.pipe(mapTo(false)));
        // when submitted, submitFirstThenUponChanges
        var changesOnSubmit$ = submit$.pipe(switchMap(function (submit) { return (submit ? controlChanges$.pipe(startWith(true)) : NEVER); }));
        // on reset, clear ComponentRef and customAnchorDestroyFn
        this.reset$.pipe(takeUntil(this.destroy)).subscribe(function () { return _this.clearRefs(); });
        merge(changesOnAsync$, changesOnBlur$, changesOnSubmit$)
            .pipe(takeUntil(this.destroy))
            .subscribe(function () { return _this.valueChanges(); });
    };
    ControlErrorsDirective.prototype.setError = function (text, error) {
        if (!this.ref) {
            var factory = this.resolver.resolveComponentFactory(this.mergedConfig.controlErrorComponent);
            this.ref = this.anchor.createComponent(factory);
        }
        var instance = this.ref.instance;
        if (this.controlErrorsTpl) {
            instance.createTemplate(this.controlErrorsTpl, error, text);
        }
        else {
            instance.text = text;
        }
        if (this.controlErrorsClass) {
            instance.customClass = this.controlErrorsClass;
        }
        if (this.mergedConfig.controlErrorComponentAnchorFn) {
            this.customAnchorDestroyFn = this.mergedConfig.controlErrorComponentAnchorFn(this.host.nativeElement, this.ref.hostView.rootNodes[0]);
        }
    };
    ControlErrorsDirective.prototype.ngOnDestroy = function () {
        this.destroy.next();
        this.clearRefs();
    };
    ControlErrorsDirective.prototype.clearRefs = function () {
        if (this.customAnchorDestroyFn) {
            this.customAnchorDestroyFn();
            this.customAnchorDestroyFn = null;
        }
        if (this.ref) {
            this.ref.destroy();
        }
        this.ref = null;
    };
    ControlErrorsDirective.prototype.valueChanges = function () {
        var controlErrors = this.control.errors;
        if (controlErrors) {
            var _a = __read(Object.keys(controlErrors), 1), firstKey = _a[0];
            var getError = this.customErrors[firstKey] || this.globalErrors[firstKey];
            if (!getError) {
                return;
            }
            var text = typeof getError === 'function' ? getError(controlErrors[firstKey]) : getError;
            this.setError(text, controlErrors);
        }
        else if (this.ref) {
            this.setError(null);
        }
    };
    ControlErrorsDirective.prototype.resolveAnchor = function () {
        if (this.controlErrorAnchor) {
            return this.controlErrorAnchor.vcr;
        }
        if (this.controlErrorAnchorParent) {
            return this.controlErrorAnchorParent.vcr;
        }
        return this.vcr;
    };
    ControlErrorsDirective.prototype.buildConfig = function () {
        return __assign({
            blurPredicate: function (element) {
                return element.tagName === 'INPUT' || element.tagName === 'SELECT';
            },
            controlErrorComponent: DefaultControlErrorComponent
        }, this.config);
    };
    ControlErrorsDirective.ctorParameters = function () { return [
        { type: ViewContainerRef },
        { type: ComponentFactoryResolver },
        { type: ElementRef },
        { type: undefined, decorators: [{ type: Inject, args: [ErrorTailorConfigProvider,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [FORM_ERRORS,] }] },
        { type: ControlErrorAnchorDirective, decorators: [{ type: Optional }] },
        { type: FormActionDirective, decorators: [{ type: Optional }] },
        { type: NgControl, decorators: [{ type: Optional }, { type: Self }] },
        { type: ControlContainer, decorators: [{ type: Optional }, { type: Self }] }
    ]; };
    __decorate([
        Input('controlErrors')
    ], ControlErrorsDirective.prototype, "customErrors", void 0);
    __decorate([
        Input()
    ], ControlErrorsDirective.prototype, "controlErrorsClass", void 0);
    __decorate([
        Input()
    ], ControlErrorsDirective.prototype, "controlErrorsTpl", void 0);
    __decorate([
        Input()
    ], ControlErrorsDirective.prototype, "controlErrorsOnAsync", void 0);
    __decorate([
        Input()
    ], ControlErrorsDirective.prototype, "controlErrorsOnBlur", void 0);
    __decorate([
        Input()
    ], ControlErrorsDirective.prototype, "controlErrorAnchor", void 0);
    ControlErrorsDirective = __decorate([
        Directive({
            selector: '[formControlName]:not([controlErrorsIgnore]), [formControl]:not([controlErrorsIgnore]), [formGroup]:not([controlErrorsIgnore]), [formGroupName]:not([controlErrorsIgnore]), [formArrayName]:not([controlErrorsIgnore]), [ngModel]:not([controlErrorsIgnore])'
        }),
        __param(3, Inject(ErrorTailorConfigProvider)),
        __param(4, Inject(FORM_ERRORS)),
        __param(5, Optional()),
        __param(6, Optional()),
        __param(7, Optional()), __param(7, Self()),
        __param(8, Optional()), __param(8, Self())
    ], ControlErrorsDirective);
    return ControlErrorsDirective;
}());

var api = [DefaultControlErrorComponent, ControlErrorAnchorDirective, ControlErrorsDirective, FormActionDirective];
var ErrorTailorModule = /** @class */ (function () {
    function ErrorTailorModule() {
    }
    ErrorTailorModule_1 = ErrorTailorModule;
    ErrorTailorModule.forRoot = function (config) {
        if (config === void 0) { config = {}; }
        return {
            ngModule: ErrorTailorModule_1,
            providers: [
                {
                    provide: ErrorTailorConfigProvider,
                    useValue: config
                },
                __assign({ provide: FORM_ERRORS }, config.errors)
            ]
        };
    };
    var ErrorTailorModule_1;
    ErrorTailorModule = ErrorTailorModule_1 = __decorate([
        NgModule({
            declarations: [
                ControlErrorsDirective,
                ControlErrorAnchorDirective,
                DefaultControlErrorComponent,
                FormActionDirective
            ],
            imports: [CommonModule],
            exports: [api],
            entryComponents: [DefaultControlErrorComponent]
        })
    ], ErrorTailorModule);
    return ErrorTailorModule;
}());

/*
 * Public API Surface of error-tailor
 */

/**
 * Generated bundle index. Do not edit.
 */

export { ControlErrorAnchorDirective, ControlErrorsDirective, DefaultControlErrorComponent, ErrorTailorConfigProvider, ErrorTailorModule, FORM_ERRORS, FormActionDirective };
//# sourceMappingURL=ngneat-error-tailor.js.map
