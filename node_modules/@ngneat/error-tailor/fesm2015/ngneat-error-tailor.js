import { __decorate, __param } from 'tslib';
import { ChangeDetectorRef, ElementRef, Component, ChangeDetectionStrategy, ViewContainerRef, Directive, InjectionToken, ComponentFactoryResolver, Inject, Optional, Self, Input, NgModule } from '@angular/core';
import { NgControl, ControlContainer } from '@angular/forms';
import { fromEvent, Subject, EMPTY, merge, NEVER } from 'rxjs';
import { tap, shareReplay, distinctUntilChanged, startWith, switchMap, mapTo, takeUntil } from 'rxjs/operators';
import { CommonModule } from '@angular/common';

let DefaultControlErrorComponent = class DefaultControlErrorComponent {
    constructor(cdr, host) {
        this.cdr = cdr;
        this.host = host;
        this.errorText = null;
        this.hideError = true;
    }
    createTemplate(tpl, error, text) {
        this.errorTemplate = tpl;
        this.errorContext = { $implicit: error, text };
        this.cdr.markForCheck();
    }
    set customClass(className) {
        this.host.nativeElement.classList.add(className);
    }
    set text(value) {
        if (value !== this.errorText) {
            this.errorText = value;
            this.hideError = !value;
            this.cdr.markForCheck();
        }
    }
};
DefaultControlErrorComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef }
];
DefaultControlErrorComponent = __decorate([
    Component({
        selector: 'control-error',
        template: `
    <label class="control-error" [class.hide-control]="hideError" *ngIf="!errorTemplate">{{ errorText }}</label>
    <ng-template *ngTemplateOutlet="errorTemplate; context: errorContext"></ng-template>
  `,
        changeDetection: ChangeDetectionStrategy.OnPush,
        styles: [`
      .hide-control {
        display: none !important;
      }

      :host {
        display: block;
      }
    `]
    })
], DefaultControlErrorComponent);

let ControlErrorAnchorDirective = class ControlErrorAnchorDirective {
    constructor(vcr) {
        this.vcr = vcr;
    }
};
ControlErrorAnchorDirective.ctorParameters = () => [
    { type: ViewContainerRef }
];
ControlErrorAnchorDirective = __decorate([
    Directive({
        selector: '[controlErrorAnchor]',
        exportAs: 'controlErrorAnchor'
    })
], ControlErrorAnchorDirective);

const FORM_ERRORS = new InjectionToken('FORM_ERRORS', {
    providedIn: 'root',
    factory: () => {
        return {};
    }
});
const ErrorTailorConfigProvider = new InjectionToken('ErrorTailorConfigProvider');

let FormActionDirective = class FormActionDirective {
    constructor(host) {
        this.host = host;
        this.submit$ = fromEvent(this.element, 'submit').pipe(tap(() => {
            if (this.element.classList.contains('form-submitted') === false) {
                this.element.classList.add('form-submitted');
            }
        }), shareReplay({ refCount: true, bufferSize: 1 }));
        this.reset$ = fromEvent(this.element, 'reset').pipe(tap(() => {
            this.element.classList.remove('form-submitted');
        }), shareReplay({ refCount: true, bufferSize: 1 }));
    }
    get element() {
        return this.host.nativeElement;
    }
};
FormActionDirective.ctorParameters = () => [
    { type: ElementRef }
];
FormActionDirective = __decorate([
    Directive({
        selector: 'form[errorTailor]'
    })
], FormActionDirective);

let ControlErrorsDirective = class ControlErrorsDirective {
    constructor(vcr, resolver, host, config, globalErrors, controlErrorAnchorParent, form, ngControl, controlContainer) {
        this.vcr = vcr;
        this.resolver = resolver;
        this.host = host;
        this.config = config;
        this.globalErrors = globalErrors;
        this.controlErrorAnchorParent = controlErrorAnchorParent;
        this.form = form;
        this.ngControl = ngControl;
        this.controlContainer = controlContainer;
        this.customErrors = {};
        this.controlErrorsOnAsync = true;
        this.controlErrorsOnBlur = true;
        this.destroy = new Subject();
        this.mergedConfig = {};
        this.submit$ = this.form ? this.form.submit$ : EMPTY;
        this.reset$ = this.form ? this.form.reset$ : EMPTY;
        this.mergedConfig = this.buildConfig();
    }
    ngOnInit() {
        this.anchor = this.resolveAnchor();
        this.control = (this.controlContainer || this.ngControl).control;
        const hasAsyncValidator = !!this.control.asyncValidator;
        const isInput = this.mergedConfig.blurPredicate(this.host.nativeElement);
        const statusChanges$ = this.control.statusChanges.pipe(distinctUntilChanged());
        const valueChanges$ = this.control.valueChanges;
        const controlChanges$ = merge(statusChanges$, valueChanges$);
        let changesOnAsync$ = EMPTY;
        let changesOnBlur$ = EMPTY;
        if (this.controlErrorsOnAsync && hasAsyncValidator) {
            // hasAsyncThenUponStatusChange
            changesOnAsync$ = statusChanges$.pipe(startWith(true));
        }
        if (this.controlErrorsOnBlur && isInput) {
            const blur$ = fromEvent(this.host.nativeElement, 'focusout');
            // blurFirstThenUponChange
            changesOnBlur$ = blur$.pipe(switchMap(() => valueChanges$.pipe(startWith(true))));
        }
        const submit$ = merge(this.submit$.pipe(mapTo(true)), this.reset$.pipe(mapTo(false)));
        // when submitted, submitFirstThenUponChanges
        const changesOnSubmit$ = submit$.pipe(switchMap(submit => (submit ? controlChanges$.pipe(startWith(true)) : NEVER)));
        // on reset, clear ComponentRef and customAnchorDestroyFn
        this.reset$.pipe(takeUntil(this.destroy)).subscribe(() => this.clearRefs());
        merge(changesOnAsync$, changesOnBlur$, changesOnSubmit$)
            .pipe(takeUntil(this.destroy))
            .subscribe(() => this.valueChanges());
    }
    setError(text, error) {
        if (!this.ref) {
            const factory = this.resolver.resolveComponentFactory(this.mergedConfig.controlErrorComponent);
            this.ref = this.anchor.createComponent(factory);
        }
        const instance = this.ref.instance;
        if (this.controlErrorsTpl) {
            instance.createTemplate(this.controlErrorsTpl, error, text);
        }
        else {
            instance.text = text;
        }
        if (this.controlErrorsClass) {
            instance.customClass = this.controlErrorsClass;
        }
        if (this.mergedConfig.controlErrorComponentAnchorFn) {
            this.customAnchorDestroyFn = this.mergedConfig.controlErrorComponentAnchorFn(this.host.nativeElement, this.ref.hostView.rootNodes[0]);
        }
    }
    ngOnDestroy() {
        this.destroy.next();
        this.clearRefs();
    }
    clearRefs() {
        if (this.customAnchorDestroyFn) {
            this.customAnchorDestroyFn();
            this.customAnchorDestroyFn = null;
        }
        if (this.ref) {
            this.ref.destroy();
        }
        this.ref = null;
    }
    valueChanges() {
        const controlErrors = this.control.errors;
        if (controlErrors) {
            const [firstKey] = Object.keys(controlErrors);
            const getError = this.customErrors[firstKey] || this.globalErrors[firstKey];
            if (!getError) {
                return;
            }
            const text = typeof getError === 'function' ? getError(controlErrors[firstKey]) : getError;
            this.setError(text, controlErrors);
        }
        else if (this.ref) {
            this.setError(null);
        }
    }
    resolveAnchor() {
        if (this.controlErrorAnchor) {
            return this.controlErrorAnchor.vcr;
        }
        if (this.controlErrorAnchorParent) {
            return this.controlErrorAnchorParent.vcr;
        }
        return this.vcr;
    }
    buildConfig() {
        return Object.assign({
            blurPredicate(element) {
                return element.tagName === 'INPUT' || element.tagName === 'SELECT';
            },
            controlErrorComponent: DefaultControlErrorComponent
        }, this.config);
    }
};
ControlErrorsDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: ComponentFactoryResolver },
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [ErrorTailorConfigProvider,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [FORM_ERRORS,] }] },
    { type: ControlErrorAnchorDirective, decorators: [{ type: Optional }] },
    { type: FormActionDirective, decorators: [{ type: Optional }] },
    { type: NgControl, decorators: [{ type: Optional }, { type: Self }] },
    { type: ControlContainer, decorators: [{ type: Optional }, { type: Self }] }
];
__decorate([
    Input('controlErrors')
], ControlErrorsDirective.prototype, "customErrors", void 0);
__decorate([
    Input()
], ControlErrorsDirective.prototype, "controlErrorsClass", void 0);
__decorate([
    Input()
], ControlErrorsDirective.prototype, "controlErrorsTpl", void 0);
__decorate([
    Input()
], ControlErrorsDirective.prototype, "controlErrorsOnAsync", void 0);
__decorate([
    Input()
], ControlErrorsDirective.prototype, "controlErrorsOnBlur", void 0);
__decorate([
    Input()
], ControlErrorsDirective.prototype, "controlErrorAnchor", void 0);
ControlErrorsDirective = __decorate([
    Directive({
        selector: '[formControlName]:not([controlErrorsIgnore]), [formControl]:not([controlErrorsIgnore]), [formGroup]:not([controlErrorsIgnore]), [formGroupName]:not([controlErrorsIgnore]), [formArrayName]:not([controlErrorsIgnore]), [ngModel]:not([controlErrorsIgnore])'
    }),
    __param(3, Inject(ErrorTailorConfigProvider)),
    __param(4, Inject(FORM_ERRORS)),
    __param(5, Optional()),
    __param(6, Optional()),
    __param(7, Optional()), __param(7, Self()),
    __param(8, Optional()), __param(8, Self())
], ControlErrorsDirective);

var ErrorTailorModule_1;
const api = [DefaultControlErrorComponent, ControlErrorAnchorDirective, ControlErrorsDirective, FormActionDirective];
let ErrorTailorModule = ErrorTailorModule_1 = class ErrorTailorModule {
    static forRoot(config = {}) {
        return {
            ngModule: ErrorTailorModule_1,
            providers: [
                {
                    provide: ErrorTailorConfigProvider,
                    useValue: config
                },
                Object.assign({ provide: FORM_ERRORS }, config.errors)
            ]
        };
    }
};
ErrorTailorModule = ErrorTailorModule_1 = __decorate([
    NgModule({
        declarations: [
            ControlErrorsDirective,
            ControlErrorAnchorDirective,
            DefaultControlErrorComponent,
            FormActionDirective
        ],
        imports: [CommonModule],
        exports: [api],
        entryComponents: [DefaultControlErrorComponent]
    })
], ErrorTailorModule);

/*
 * Public API Surface of error-tailor
 */

/**
 * Generated bundle index. Do not edit.
 */

export { ControlErrorAnchorDirective, ControlErrorsDirective, DefaultControlErrorComponent, ErrorTailorConfigProvider, ErrorTailorModule, FORM_ERRORS, FormActionDirective };
//# sourceMappingURL=ngneat-error-tailor.js.map
