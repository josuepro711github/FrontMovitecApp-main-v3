import { __decorate, __param } from 'tslib';
import { ChangeDetectorRef, ElementRef, Component, ChangeDetectionStrategy, ViewContainerRef, Directive, InjectionToken, ComponentFactoryResolver, Inject, Optional, Self, Input, NgModule } from '@angular/core';
import { NgControl, ControlContainer } from '@angular/forms';
import { fromEvent, Subject, EMPTY, merge, NEVER } from 'rxjs';
import { tap, shareReplay, distinctUntilChanged, startWith, switchMap, mapTo, takeUntil } from 'rxjs/operators';
import { CommonModule } from '@angular/common';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from '@angular/forms';

function DefaultControlErrorComponent_label_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "label", 2);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("hide-control", ctx_r0.hideError);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.errorText);
} }
function DefaultControlErrorComponent_1_ng_template_0_Template(rf, ctx) { }
function DefaultControlErrorComponent_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, DefaultControlErrorComponent_1_ng_template_0_Template, 0, 0, "ng-template");
} }
let DefaultControlErrorComponent = class DefaultControlErrorComponent {
    constructor(cdr, host) {
        this.cdr = cdr;
        this.host = host;
        this.errorText = null;
        this.hideError = true;
    }
    createTemplate(tpl, error, text) {
        this.errorTemplate = tpl;
        this.errorContext = { $implicit: error, text };
        this.cdr.markForCheck();
    }
    set customClass(className) {
        this.host.nativeElement.classList.add(className);
    }
    set text(value) {
        if (value !== this.errorText) {
            this.errorText = value;
            this.hideError = !value;
            this.cdr.markForCheck();
        }
    }
};
DefaultControlErrorComponent.ɵfac = function DefaultControlErrorComponent_Factory(t) { return new (t || DefaultControlErrorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
DefaultControlErrorComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: DefaultControlErrorComponent, selectors: [["control-error"]], decls: 2, vars: 3, consts: [["class", "control-error", 3, "hide-control", 4, "ngIf"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "control-error"]], template: function DefaultControlErrorComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, DefaultControlErrorComponent_label_0_Template, 2, 3, "label", 0);
        ɵngcc0.ɵɵtemplate(1, DefaultControlErrorComponent_1_Template, 1, 0, undefined, 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.errorTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.errorTemplate)("ngTemplateOutletContext", ctx.errorContext);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet], styles: [".hide-control[_ngcontent-%COMP%] {\n        display: none !important;\n      }\n\n      [_nghost-%COMP%] {\n        display: block;\n      }"], changeDetection: 0 });
DefaultControlErrorComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef }
];

let ControlErrorAnchorDirective = class ControlErrorAnchorDirective {
    constructor(vcr) {
        this.vcr = vcr;
    }
};
ControlErrorAnchorDirective.ɵfac = function ControlErrorAnchorDirective_Factory(t) { return new (t || ControlErrorAnchorDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
ControlErrorAnchorDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: ControlErrorAnchorDirective, selectors: [["", "controlErrorAnchor", ""]], exportAs: ["controlErrorAnchor"] });
ControlErrorAnchorDirective.ctorParameters = () => [
    { type: ViewContainerRef }
];

const FORM_ERRORS = new InjectionToken('FORM_ERRORS', {
    providedIn: 'root',
    factory: () => {
        return {};
    }
});
const ErrorTailorConfigProvider = new InjectionToken('ErrorTailorConfigProvider');

let FormActionDirective = class FormActionDirective {
    constructor(host) {
        this.host = host;
        this.submit$ = fromEvent(this.element, 'submit').pipe(tap(() => {
            if (this.element.classList.contains('form-submitted') === false) {
                this.element.classList.add('form-submitted');
            }
        }), shareReplay({ refCount: true, bufferSize: 1 }));
        this.reset$ = fromEvent(this.element, 'reset').pipe(tap(() => {
            this.element.classList.remove('form-submitted');
        }), shareReplay({ refCount: true, bufferSize: 1 }));
    }
    get element() {
        return this.host.nativeElement;
    }
};
FormActionDirective.ɵfac = function FormActionDirective_Factory(t) { return new (t || FormActionDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
FormActionDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: FormActionDirective, selectors: [["form", "errorTailor", ""]] });
FormActionDirective.ctorParameters = () => [
    { type: ElementRef }
];

let ControlErrorsDirective = class ControlErrorsDirective {
    constructor(vcr, resolver, host, config, globalErrors, controlErrorAnchorParent, form, ngControl, controlContainer) {
        this.vcr = vcr;
        this.resolver = resolver;
        this.host = host;
        this.config = config;
        this.globalErrors = globalErrors;
        this.controlErrorAnchorParent = controlErrorAnchorParent;
        this.form = form;
        this.ngControl = ngControl;
        this.controlContainer = controlContainer;
        this.customErrors = {};
        this.controlErrorsOnAsync = true;
        this.controlErrorsOnBlur = true;
        this.destroy = new Subject();
        this.mergedConfig = {};
        this.submit$ = this.form ? this.form.submit$ : EMPTY;
        this.reset$ = this.form ? this.form.reset$ : EMPTY;
        this.mergedConfig = this.buildConfig();
    }
    ngOnInit() {
        this.anchor = this.resolveAnchor();
        this.control = (this.controlContainer || this.ngControl).control;
        const hasAsyncValidator = !!this.control.asyncValidator;
        const isInput = this.mergedConfig.blurPredicate(this.host.nativeElement);
        const statusChanges$ = this.control.statusChanges.pipe(distinctUntilChanged());
        const valueChanges$ = this.control.valueChanges;
        const controlChanges$ = merge(statusChanges$, valueChanges$);
        let changesOnAsync$ = EMPTY;
        let changesOnBlur$ = EMPTY;
        if (this.controlErrorsOnAsync && hasAsyncValidator) {
            // hasAsyncThenUponStatusChange
            changesOnAsync$ = statusChanges$.pipe(startWith(true));
        }
        if (this.controlErrorsOnBlur && isInput) {
            const blur$ = fromEvent(this.host.nativeElement, 'focusout');
            // blurFirstThenUponChange
            changesOnBlur$ = blur$.pipe(switchMap(() => valueChanges$.pipe(startWith(true))));
        }
        const submit$ = merge(this.submit$.pipe(mapTo(true)), this.reset$.pipe(mapTo(false)));
        // when submitted, submitFirstThenUponChanges
        const changesOnSubmit$ = submit$.pipe(switchMap(submit => (submit ? controlChanges$.pipe(startWith(true)) : NEVER)));
        // on reset, clear ComponentRef and customAnchorDestroyFn
        this.reset$.pipe(takeUntil(this.destroy)).subscribe(() => this.clearRefs());
        merge(changesOnAsync$, changesOnBlur$, changesOnSubmit$)
            .pipe(takeUntil(this.destroy))
            .subscribe(() => this.valueChanges());
    }
    setError(text, error) {
        if (!this.ref) {
            const factory = this.resolver.resolveComponentFactory(this.mergedConfig.controlErrorComponent);
            this.ref = this.anchor.createComponent(factory);
        }
        const instance = this.ref.instance;
        if (this.controlErrorsTpl) {
            instance.createTemplate(this.controlErrorsTpl, error, text);
        }
        else {
            instance.text = text;
        }
        if (this.controlErrorsClass) {
            instance.customClass = this.controlErrorsClass;
        }
        if (this.mergedConfig.controlErrorComponentAnchorFn) {
            this.customAnchorDestroyFn = this.mergedConfig.controlErrorComponentAnchorFn(this.host.nativeElement, this.ref.hostView.rootNodes[0]);
        }
    }
    ngOnDestroy() {
        this.destroy.next();
        this.clearRefs();
    }
    clearRefs() {
        if (this.customAnchorDestroyFn) {
            this.customAnchorDestroyFn();
            this.customAnchorDestroyFn = null;
        }
        if (this.ref) {
            this.ref.destroy();
        }
        this.ref = null;
    }
    valueChanges() {
        const controlErrors = this.control.errors;
        if (controlErrors) {
            const [firstKey] = Object.keys(controlErrors);
            const getError = this.customErrors[firstKey] || this.globalErrors[firstKey];
            if (!getError) {
                return;
            }
            const text = typeof getError === 'function' ? getError(controlErrors[firstKey]) : getError;
            this.setError(text, controlErrors);
        }
        else if (this.ref) {
            this.setError(null);
        }
    }
    resolveAnchor() {
        if (this.controlErrorAnchor) {
            return this.controlErrorAnchor.vcr;
        }
        if (this.controlErrorAnchorParent) {
            return this.controlErrorAnchorParent.vcr;
        }
        return this.vcr;
    }
    buildConfig() {
        return Object.assign({
            blurPredicate(element) {
                return element.tagName === 'INPUT' || element.tagName === 'SELECT';
            },
            controlErrorComponent: DefaultControlErrorComponent
        }, this.config);
    }
};
ControlErrorsDirective.ɵfac = function ControlErrorsDirective_Factory(t) { return new (t || ControlErrorsDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ErrorTailorConfigProvider), ɵngcc0.ɵɵdirectiveInject(FORM_ERRORS), ɵngcc0.ɵɵdirectiveInject(ControlErrorAnchorDirective, 8), ɵngcc0.ɵɵdirectiveInject(FormActionDirective, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.NgControl, 10), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.ControlContainer, 10)); };
ControlErrorsDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: ControlErrorsDirective, selectors: [["", "formControlName", "", 3, "controlErrorsIgnore", ""], ["", "formControl", "", 3, "controlErrorsIgnore", ""], ["", "formGroup", "", 3, "controlErrorsIgnore", ""], ["", "formGroupName", "", 3, "controlErrorsIgnore", ""], ["", "formArrayName", "", 3, "controlErrorsIgnore", ""], ["", "ngModel", "", 3, "controlErrorsIgnore", ""]], inputs: { customErrors: ["controlErrors", "customErrors"], controlErrorsOnAsync: "controlErrorsOnAsync", controlErrorsOnBlur: "controlErrorsOnBlur", controlErrorsClass: "controlErrorsClass", controlErrorsTpl: "controlErrorsTpl", controlErrorAnchor: "controlErrorAnchor" } });
ControlErrorsDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: ComponentFactoryResolver },
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [ErrorTailorConfigProvider,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [FORM_ERRORS,] }] },
    { type: ControlErrorAnchorDirective, decorators: [{ type: Optional }] },
    { type: FormActionDirective, decorators: [{ type: Optional }] },
    { type: NgControl, decorators: [{ type: Optional }, { type: Self }] },
    { type: ControlContainer, decorators: [{ type: Optional }, { type: Self }] }
];
__decorate([
    Input('controlErrors')
], ControlErrorsDirective.prototype, "customErrors", void 0);
__decorate([
    Input()
], ControlErrorsDirective.prototype, "controlErrorsClass", void 0);
__decorate([
    Input()
], ControlErrorsDirective.prototype, "controlErrorsTpl", void 0);
__decorate([
    Input()
], ControlErrorsDirective.prototype, "controlErrorsOnAsync", void 0);
__decorate([
    Input()
], ControlErrorsDirective.prototype, "controlErrorsOnBlur", void 0);
__decorate([
    Input()
], ControlErrorsDirective.prototype, "controlErrorAnchor", void 0);
ControlErrorsDirective = __decorate([ __param(3, Inject(ErrorTailorConfigProvider)),
    __param(4, Inject(FORM_ERRORS)),
    __param(5, Optional()),
    __param(6, Optional()),
    __param(7, Optional()), __param(7, Self()),
    __param(8, Optional()), __param(8, Self())
], ControlErrorsDirective);

var ErrorTailorModule_1;
const api = [DefaultControlErrorComponent, ControlErrorAnchorDirective, ControlErrorsDirective, FormActionDirective];
let ErrorTailorModule = ErrorTailorModule_1 = class ErrorTailorModule {
    static forRoot(config = {}) {
        return {
            ngModule: ErrorTailorModule_1,
            providers: [
                {
                    provide: ErrorTailorConfigProvider,
                    useValue: config
                },
                Object.assign({ provide: FORM_ERRORS }, config.errors)
            ]
        };
    }
};
ErrorTailorModule.ɵfac = function ErrorTailorModule_Factory(t) { return new (t || ErrorTailorModule)(); };
ErrorTailorModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: ErrorTailorModule });
ErrorTailorModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DefaultControlErrorComponent, [{
        type: Component,
        args: [{
                selector: 'control-error',
                template: `
    <label class="control-error" [class.hide-control]="hideError" *ngIf="!errorTemplate">{{ errorText }}</label>
    <ng-template *ngTemplateOutlet="errorTemplate; context: errorContext"></ng-template>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [`
      .hide-control {
        display: none !important;
      }

      :host {
        display: block;
      }
    `]
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ControlErrorAnchorDirective, [{
        type: Directive,
        args: [{
                selector: '[controlErrorAnchor]',
                exportAs: 'controlErrorAnchor'
            }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FormActionDirective, [{
        type: Directive,
        args: [{
                selector: 'form[errorTailor]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ControlErrorsDirective, [{
        type: Directive,
        args: [{
                selector: '[formControlName]:not([controlErrorsIgnore]), [formControl]:not([controlErrorsIgnore]), [formGroup]:not([controlErrorsIgnore]), [formGroupName]:not([controlErrorsIgnore]), [formArrayName]:not([controlErrorsIgnore]), [ngModel]:not([controlErrorsIgnore])'
            }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.ElementRef }, { type: undefined, decorators: [{
                type: Inject,
                args: [ErrorTailorConfigProvider]
            }] }, { type: undefined, decorators: [{
                type: Inject,
                args: [FORM_ERRORS]
            }] }, { type: ControlErrorAnchorDirective, decorators: [{
                type: Optional
            }] }, { type: FormActionDirective, decorators: [{
                type: Optional
            }] }, { type: ɵngcc2.NgControl, decorators: [{
                type: Optional
            }, {
                type: Self
            }] }, { type: ɵngcc2.ControlContainer, decorators: [{
                type: Optional
            }, {
                type: Self
            }] }]; }, { customErrors: [{
            type: Input,
            args: ['controlErrors']
        }], controlErrorsOnAsync: [{
            type: Input
        }], controlErrorsOnBlur: [{
            type: Input
        }], controlErrorsClass: [{
            type: Input
        }], controlErrorsTpl: [{
            type: Input
        }], controlErrorAnchor: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ErrorTailorModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    ControlErrorsDirective,
                    ControlErrorAnchorDirective,
                    DefaultControlErrorComponent,
                    FormActionDirective
                ],
                imports: [CommonModule],
                exports: [api],
                entryComponents: [DefaultControlErrorComponent]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ErrorTailorModule, { declarations: function () { return [ControlErrorsDirective, ControlErrorAnchorDirective, DefaultControlErrorComponent, FormActionDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [DefaultControlErrorComponent, ControlErrorAnchorDirective, ControlErrorsDirective, FormActionDirective]; } }); })();

/*
 * Public API Surface of error-tailor
 */

/**
 * Generated bundle index. Do not edit.
 */

export { ControlErrorAnchorDirective, ControlErrorsDirective, DefaultControlErrorComponent, ErrorTailorConfigProvider, ErrorTailorModule, FORM_ERRORS, FormActionDirective };

//# sourceMappingURL=ngneat-error-tailor.js.map